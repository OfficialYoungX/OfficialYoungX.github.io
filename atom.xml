<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RandomYang</title>
  
  <subtitle>Code + Design =&gt; Magic</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.randomyang.top/"/>
  <updated>2020-03-19T04:33:34.677Z</updated>
  <id>http://www.randomyang.top/</id>
  
  <author>
    <name>RandomYang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[译]使用WebGL创建伪3D图像效果</title>
    <link href="http://www.randomyang.top/2020/03/08/%E8%AF%91-%E4%BD%BF%E7%94%A8WebGL%E5%88%9B%E5%BB%BA%E4%BC%AA3D%E5%9B%BE%E5%83%8F%E6%95%88%E6%9E%9C/"/>
    <id>http://www.randomyang.top/2020/03/08/%E8%AF%91-%E4%BD%BF%E7%94%A8WebGL%E5%88%9B%E5%BB%BA%E4%BC%AA3D%E5%9B%BE%E5%83%8F%E6%95%88%E6%9E%9C/</id>
    <published>2020-03-08T05:18:32.000Z</published>
    <updated>2020-03-19T04:33:34.677Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="https://tympanus.net/codrops/2019/02/20/how-to-create-a-fake-3d-image-effect-with-webgl/" target="_blank" rel="noopener">https://tympanus.net/codrops/2019/02/20/how-to-create-a-fake-3d-image-effect-with-webgl/</a></p></blockquote><p>学习如何用原生 WebGL 为具有深度映射的图像创建交互式伪 3D 效果。</p><p><img src="https://source-hosting.oss-cn-shanghai.aliyuncs.com/Fake3dEffect_featured.jpg" alt></p><blockquote><p>demo: <a href="http://tympanus.net/Tutorials/Fake3DEffect/" target="_blank" rel="noopener">http://tympanus.net/Tutorials/Fake3DEffect/</a> [译者注：强烈建议你点进去看看！]<br>Get 源代码: <a href="http://tympanus.net/Tutorials/Fake3DEffect/Fake3DEffect.zip" target="_blank" rel="noopener">http://tympanus.net/Tutorials/Fake3DEffect/Fake3DEffect.zip</a></p></blockquote><p>如今，WebGL 变得非常流行，因为它让我们能够为 Web 创建独特的交互式图形。您可能已经看到使用<a href="https://tympanus.net/codrops/2019/02/06/text-distortion-effects-using-blotter-js/" target="_blank" rel="noopener">Blotter.js 创建文字失真效果</a>或使用<a href="https://tympanus.net/codrops/2019/01/08/animated-mesh-lines/" target="_blank" rel="noopener">THREE.MeshLine 库创建的 WebGL 动画曲线</a>。今天，您将了解如何直接使用原生 WebGL 快速为图像创建交互式的伪 3D 效果。</p><p>如果使用 Facebook，则可能会看到<a href="https://facebook360.fb.com/2018/10/11/3d-photos-now-rolling-out-on-facebook-and-in-vr/" target="_blank" rel="noopener">新闻源和 VR 的 3D 照片</a>更新。借助特殊的电话摄像头，可以捕捉前景中的对象与背景之间的距离，从而使 3D 照片通过景深和微小位移使场景栩栩如生。我们可以使用<strong>任何</strong>照片，一些图像编辑和一点点编码来重新创建这种效果。</p><p>通常，这类效果将依赖 Three.js 或 Pixi.js，这两个都是功能强大的库，在编码时具有许多有用且便捷的功能。今天，我们将不使用任何库，而是直接用原生的 WebGL API。</p><p>所以，赶快开始吧！</p><h2 id="画一个平面"><a href="#画一个平面" class="headerlink" title="画一个平面"></a>画一个平面</h2><p>所以，为了实现这种效果，我们使用原生的 WebGL API. 这里有个让你入门 WebGL 的好地方 <a href="https://webglfundamentals.org/" target="_blank" rel="noopener">webglfundamentals.org</a>. WebGL 通常因其冗长而遭到开发者的抱怨，其实，这是有原因的。所有全屏着色器效果（即使它们是 2D 效果）的基础是某种平面或网格，即所谓的四边形，它在整个屏幕上延伸。通常我们在 Three.js 中编写<code>THREE.PlaneGeometry(1,1)</code>来创建 1×1 平面，而我们在原生 WebGL 中需要写：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> vertices = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Float32Array</span>([<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>])<span class="hljs-keyword">let</span> buffer = gl.createBuffer()gl.bindBuffer(gl.ARRAY_BUFFER, buffer)gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW)</code></pre><p>现在我们有了平面，我们可以对其应用顶点和片段着色器。</p><h2 id="准备图像"><a href="#准备图像" class="headerlink" title="准备图像"></a>准备图像</h2><p>为了创建 3D 效果，我们需要创建图像的深度图。制作深度图的主要原理是，我们必须根据图像中对象的 Z 坐标来分离图像由近到远的不同部分，从而将前景与背景分隔开。</p><p>为此，我们可以通过以下方式在 Photoshop 中打开图像并在原始照片上绘制灰色区域：<br><img src="https://source-hosting.oss-cn-shanghai.aliyuncs.com/fake3d_01.gif" alt><br>[译者注：其实这里的图片处理非常重要，将会直接影响到最后的效果。这里，我找到了一个<a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwjXkpWAroroAhVLL6YKHftmBMkQwqsBMAB6BAgKEAQ&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DLQ0RuWf-J1k&amp;usg=AOvVaw2aUR2TWSNuh9NvqC3xLrML" target="_blank" rel="noopener">如何在 photoshop 中创建图像的深度图</a>的简易教程]</p><p>此图显示了一些山脉，在这些山脉中您可以看到图中对象离相机越近，深度图中的区域绘制得越亮。在接下来的一部分中，让我们看看为什么这种阴影很有意义。</p><h2 id="编写着色器"><a href="#编写着色器" class="headerlink" title="编写着色器"></a>编写着色器</h2><p>渲染逻辑主要发生在着色器中。如 MDN 网站文档所述：</p><blockquote><p>着色器是使用 OpenGL ES 着色语言(GLSL)编写的程序，该程序获取有关构成形状的顶点的信息，并生成将像素渲染到屏幕上所需的数据：即像素的位置及其像素颜色。绘制 WebGL 内容时，有两个着色器功能运行：顶点着色器和片段着色器。</p></blockquote><p>了解着色器的一个很好的资源是 <a href="https://thebookofshaders.com/" target="_blank" rel="noopener">The Book Of Shaders</a>。</p><p>顶点着色器的作用在这并不复杂。它只显示顶点：</p><pre><code class="hljs glsl"><span class="hljs-keyword">attribute</span> <span class="hljs-type">vec2</span> position;    <span class="hljs-type">void</span> main() &#123;    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-type">vec4</span>(position, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);&#125;</code></pre><p>最有趣的部分将发生在片段着色器中。我们将在片段着色器中加载两张图片：</p><pre><code class="hljs glsl"><span class="hljs-type">void</span> main()&#123;    <span class="hljs-type">vec4</span> depth = <span class="hljs-built_in">texture2D</span>(depthImage, uv);    <span class="hljs-built_in">gl_FragColor</span> = <span class="hljs-built_in">texture2D</span>(originalImage, uv); <span class="hljs-comment">// 只是显示原图</span>&#125;</code></pre><p>需要指明的是，深度图图像是黑白的。对于着色器，颜色只是一个数字：1 是白色，0 是深黑色。uv 变量是一个二维映射，用于存储有关要显示哪个像素的信息。通过这两件事，我们可以使用深度信息稍微移动原始照片的像素。</p><p>让我们从鼠标移动开始：</p><pre><code class="hljs glsl"><span class="hljs-type">vec4</span> depth = <span class="hljs-built_in">texture2D</span>(depthImage, uv);<span class="hljs-built_in">gl_FragColor</span> = <span class="hljs-built_in">texture2D</span>(originalImage, uv + mouse); <span class="hljs-comment">// 译者注：这里每一个顶点的位移都是完全相同的</span></code></pre><p>[译者注：<a href="http://wiki.winamp.com/wiki/Pixel_Shader_Basics#UV_Coordinates" target="_blank" rel="noopener">关于 uv</a>]<br><img src="https://source-hosting.oss-cn-shanghai.aliyuncs.com/fake3d_002.gif" alt></p><p>现在让我们添加深度信息：</p><pre><code class="hljs glsl"><span class="hljs-type">vec4</span> depth = <span class="hljs-built_in">texture2D</span>(depthImage, uv);<span class="hljs-built_in">gl_FragColor</span> = <span class="hljs-built_in">texture2D</span>(originalImage, uv + mouse*depth.r);</code></pre><p>该见证奇迹了：<br><img src="https://source-hosting.oss-cn-shanghai.aliyuncs.com/fake3d_03.gif" alt></p><p>因为 depth 纹理是黑白的，所以我们可以采用红色通道<code>depth.r</code>，并将其乘以屏幕上的鼠标位置值。这意味着像素越亮，跟随鼠标移动的像素就越多。另一方面，暗色像素只会保留在原位。它的原理是如此简单[译者注：真的简单易懂！]，但是却可以产生令人印象深刻的 3D 图像错觉。</p><p>当然，着色器能够能够做的远远不止这，但是我希望你喜欢这个「伪造」的 3D 效果小实验。让我知道您对此有何想法，并希望借此来看看你的创作！</p><h2 id="参考和鸣谢"><a href="#参考和鸣谢" class="headerlink" title="参考和鸣谢"></a>参考和鸣谢</h2><ul><li><a href="https://github.com/dorukeker/gyronorm.js/" target="_blank" rel="noopener">Gyronorm</a> library by <a href="http://dorukeker.com/" target="_blank" rel="noopener">Doruk Eker</a></li><li>Photo by <a href="https://unsplash.com/photos/YK_8mABhrtc" target="_blank" rel="noopener">Cosmic Timetraveler</a></li><li>Photo by <a href="https://unsplash.com/photos/WJRZNL7rDF8" target="_blank" rel="noopener">Chelsea Ferenando</a></li><li>Photo by <a href="https://unsplash.com/photos/JnOHvMgw_Jo" target="_blank" rel="noopener">Rio Syhputra</a></li><li>Photo by <a href="https://unsplash.com/photos/3l3RwQdHRHg" target="_blank" rel="noopener">Jonatan Pie</a></li></ul><p><a href="https://github.com/akella/fake3d" target="_blank" rel="noopener">在 github 上找到完整的项目</a></p><p>译者说：</p><p>这篇文章是继<a href="http://www.randomyang.top/2019/11/02/译-使用Three-js制作Gooey图像悬停效果/">[译]使用 Three.js 制作有粘稠感的图像悬停效果</a>的又一篇有意思的同类文章。翻译不是目的，因为有了 google translate 文章的英语不在话下，而且该文表达很简单直接，目的是分享我看到的值得分享的好的内容，我个人还是觉得这些东西很有意思的。</p><p>该文涉及到的 shader 代码并不复杂，可是思路非常巧妙，进而达到了不错的效果。而且最重要的是，只要你能制作出图像对应的深度图，那么就可以模拟出伪 3D 的效果。如果你能够将图中对象的前后关系颗粒度划分得越细，那么最终得到的效果应该是会越好。</p><p>文章首发于个人<a href="http://randomyang.top/2020/03/08/译-使用WebGL创建伪3D图像效果/" target="_blank" rel="noopener">blog</a>，同收录于知乎专栏<a href="https://zhuanlan.zhihu.com/c_1109036567154388992" target="_blank" rel="noopener">前端艺术</a>，如果你对于相关内容感兴趣，欢迎关注订阅。</p><p><img src="https://source-hosting.oss-cn-shanghai.aliyuncs.com/article-tail@3x.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://tympanus.net/codrops/2019/02/20/how-to-create-a-fake-3d-image-effect-with-webgl/&quot; target=&quot;_blank&quot; rel=&quot;n
      
    
    </summary>
    
    
    
      <category term="Graphic" scheme="http://www.randomyang.top/tags/Graphic/"/>
    
      <category term="3D" scheme="http://www.randomyang.top/tags/3D/"/>
    
      <category term="glsl" scheme="http://www.randomyang.top/tags/glsl/"/>
    
      <category term="WebGL" scheme="http://www.randomyang.top/tags/WebGL/"/>
    
  </entry>
  
  <entry>
    <title>hexo博客主题「paper」的设计与开发</title>
    <link href="http://www.randomyang.top/2019/12/01/hexo%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E3%80%8Cpaper%E3%80%8D%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/"/>
    <id>http://www.randomyang.top/2019/12/01/hexo%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E3%80%8Cpaper%E3%80%8D%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/</id>
    <published>2019-12-01T08:48:48.000Z</published>
    <updated>2020-03-18T05:56:26.255Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://source-hosting.oss-cn-shanghai.aliyuncs.com/Paper-showcase.png" alt></p><blockquote><p><em>虽然麻烦，但是我还是写了个自己的博客主题叫<a href="https://github.com/OfficialYoungX/paper" target="_blank" rel="noopener">Paper</a></em></p></blockquote><p><a href="https://hexo.io/themes/" target="_blank" rel="noopener">hexo的theme</a>里面有接近300个主题，逛了一圈，似乎还是没有找到自己心仪的。看来看去，好像也就几个大的风格占了主要的比例。例如，Material Design、卡片布局、大图Landing，等等。</p><p>这些风格似乎都是近几年比较流行的博客风格，但可能是因为用的人太多，我有点审美疲劳了。趁着自己好像有点设计能力，决定写一个自己的博客主题。</p><p>这篇文章记录一下设计思想、设计过程、编码相关(其实这不是重点)。</p><h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><p><strong>Q&amp;A</strong><br>Q：主题是什么风格？<br>A：paper-like，随便翻译一下可以翻译为“类纸化”风格。主要体现在排版以及一些线条的使用上。排版借鉴了报纸的排版风格。</p><p>Q：具体参考了哪个报纸的排版设计？<br>A：我当时其实就是随便google了一张报纸，然后就开始设计了。链接我也给忘了，后面补上，长这样。<br><img src="https://source-hosting.oss-cn-shanghai.aliyuncs.com/20191214174027.jpg" alt><br>其实现在想起来，我当时应该多参考几个，不过已经有点晚了，这一点比较后悔。</p><p>其实除了借鉴真实报纸的排版以外，我还参考了另一个大名鼎鼎的设计站<a href="http://anyway.fm/" target="_blank" rel="noopener">Anyway</a>的设计，主要是其固定的边框设计(老实说我从未在其他任何网站见到过这种设计)、一宽一窄的边线设计。如果你喜欢了解设计相关的前沿信息，不妨访问Anyway设计站，他提供的信息质量都比较高。</p><p>Q：使用什么设计工具？<br>A：当下比较流行的UI矢量绘图工具<a href="https://www.sketch.com" target="_blank" rel="noopener">sketch</a>。就是一个画UI比较方便的绘图工具。用什么工具不太重要，画出来像你想的那样就行了。</p><p>Q：设计稿长什么样？<br>A：这样：<br><img src="https://source-hosting.oss-cn-shanghai.aliyuncs.com/20191214182734.png" alt><br>最终的真实页面并非和设计稿长得完全一样，因为中途编码的过程中一些小的想法有变化。并且个人感觉，也没必要完全和设计稿一样，尤其是当设计师和开发人员是同一个人的时候。。。</p><p><strong>排版</strong><br>如上所述，完全“模仿”和“魔改”的如图的报纸排版设计。作出好的排版实在是太难了，设计能力不够，所以就只有借鉴一下了。</p><p><strong>字体</strong><br>字体又是一个大坑，我看上的好的字体都要收费。无奈之下只能暂时选择中规中矩的通用方案<code>font-family: &quot;SF Pro Text&quot;,&quot;SF Pro Icons&quot;,&quot;Helvetica Neue&quot;,&quot;Helvetica&quot;,&quot;Arial&quot;,sans-serif</code><br>行高上我还是下了一定的功夫，因为行高对于阅读体验的影响比较大。参考了这位<a href="https://canisminor.cc/blog/posts/20180820_canisminor" target="_blank" rel="noopener">大佬</a>博客上的行高算法，感觉最有道理，最能说服我。<br><img src="https://source-hosting.oss-cn-shanghai.aliyuncs.com/20191214180635.png" alt><br>按照上图的计算，最后将字号和行高设定为stylu中的变量<br><pre><code class="hljs styl"><span class="hljs-comment">// font-size</span><span class="hljs-variable">$font</span>-size-s-<span class="hljs-number">1</span> = <span class="hljs-number">1.4rem</span><span class="hljs-variable">$font</span>-size-s-<span class="hljs-number">2</span> = <span class="hljs-number">1.6rem</span><span class="hljs-variable">$font</span>-size-s-<span class="hljs-number">3</span> = <span class="hljs-number">1.8rem</span><span class="hljs-variable">$font</span>-size-m-<span class="hljs-number">1</span> = <span class="hljs-number">2.2rem</span><span class="hljs-variable">$font</span>-size-m-<span class="hljs-number">2</span> = <span class="hljs-number">2.8rem</span><span class="hljs-variable">$font</span>-size-m-<span class="hljs-number">3</span> = <span class="hljs-number">3.4rem</span><span class="hljs-variable">$font</span>-size-m-<span class="hljs-number">4</span> = <span class="hljs-number">4.2rem</span><span class="hljs-variable">$font</span>-size-l-<span class="hljs-number">1</span> = <span class="hljs-number">5.2rem</span><span class="hljs-variable">$font</span>-size-l-<span class="hljs-number">2</span> = <span class="hljs-number">6.4rem</span><span class="hljs-variable">$font</span>-size-l-<span class="hljs-number">3</span> = <span class="hljs-number">7.8rem</span><span class="hljs-comment">// line-height</span><span class="hljs-variable">$line</span>-<span class="hljs-attribute">height</span>-s-<span class="hljs-number">1</span> = <span class="hljs-number">2.2rem</span><span class="hljs-variable">$line</span>-<span class="hljs-attribute">height</span>-s-<span class="hljs-number">2</span> = <span class="hljs-number">2.4rem</span><span class="hljs-variable">$line</span>-<span class="hljs-attribute">height</span>-s-<span class="hljs-number">3</span> = <span class="hljs-number">2.6rem</span><span class="hljs-variable">$line</span>-<span class="hljs-attribute">height</span>-m-<span class="hljs-number">1</span> = <span class="hljs-number">3.0rem</span><span class="hljs-variable">$line</span>-<span class="hljs-attribute">height</span>-m-<span class="hljs-number">2</span> = <span class="hljs-number">3.6rem</span><span class="hljs-variable">$line</span>-<span class="hljs-attribute">height</span>-m-<span class="hljs-number">3</span> = <span class="hljs-number">4.4rem</span><span class="hljs-variable">$line</span>-<span class="hljs-attribute">height</span>-m-<span class="hljs-number">4</span> = <span class="hljs-number">5.6rem</span><span class="hljs-variable">$line</span>-<span class="hljs-attribute">height</span>-l-<span class="hljs-number">1</span> = <span class="hljs-number">6.6rem</span><span class="hljs-variable">$line</span>-<span class="hljs-attribute">height</span>-l-<span class="hljs-number">2</span> = <span class="hljs-number">8.2rem</span><span class="hljs-variable">$line</span>-<span class="hljs-attribute">height</span>-l-<span class="hljs-number">3</span> = <span class="hljs-number">10rem</span></code></pre></p><p>再写一个stylu函数，在之后的样式中引用就好了：<br><pre><code class="hljs styl"><span class="hljs-function"><span class="hljs-title">text-size</span><span class="hljs-params">(n)</span></span>  <span class="hljs-keyword">if</span> n == <span class="hljs-string">'s-1'</span>    <span class="hljs-attribute">font-size</span>: <span class="hljs-variable">$font</span>-size-s-<span class="hljs-number">1</span>    <span class="hljs-attribute">line-height</span>: <span class="hljs-variable">$line</span>-height-s-<span class="hljs-number">1</span>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> n == <span class="hljs-string">'s-2'</span>    <span class="hljs-attribute">font-size</span>: <span class="hljs-variable">$font</span>-size-s-<span class="hljs-number">2</span>    <span class="hljs-attribute">line-height</span>: <span class="hljs-variable">$line</span>-height-s-<span class="hljs-number">2</span>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> n == <span class="hljs-string">'s-3'</span>    <span class="hljs-attribute">font-size</span>: <span class="hljs-variable">$font</span>-size-s-<span class="hljs-number">3</span>    <span class="hljs-attribute">line-height</span>: <span class="hljs-variable">$line</span>-height-s-<span class="hljs-number">3</span>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> n == <span class="hljs-string">'m-1'</span>    <span class="hljs-attribute">font-size</span>: <span class="hljs-variable">$font</span>-size-m-<span class="hljs-number">1</span>    <span class="hljs-attribute">line-height</span>: <span class="hljs-variable">$line</span>-height-m-<span class="hljs-number">1</span>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> n == <span class="hljs-string">'m-2'</span>    <span class="hljs-attribute">font-size</span>: <span class="hljs-variable">$font</span>-size-m-<span class="hljs-number">2</span>    <span class="hljs-attribute">line-height</span>: <span class="hljs-variable">$line</span>-height-m-<span class="hljs-number">2</span>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> n == <span class="hljs-string">'m-3'</span>    <span class="hljs-attribute">font-size</span>: <span class="hljs-variable">$font</span>-size-m-<span class="hljs-number">3</span>    <span class="hljs-attribute">line-height</span>: <span class="hljs-variable">$line</span>-height-m-<span class="hljs-number">3</span>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> n == <span class="hljs-string">'m-4'</span>    <span class="hljs-attribute">font-size</span>: <span class="hljs-variable">$font</span>-size-m-<span class="hljs-number">4</span>    <span class="hljs-attribute">line-height</span>: <span class="hljs-variable">$line</span>-height-m-<span class="hljs-number">4</span>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> n == <span class="hljs-string">'l-1'</span>    <span class="hljs-attribute">font-size</span>: <span class="hljs-variable">$font</span>-size-l-<span class="hljs-number">1</span>    <span class="hljs-attribute">line-height</span>: <span class="hljs-variable">$line</span>-height-l-<span class="hljs-number">1</span>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> n == <span class="hljs-string">'l-2'</span>    <span class="hljs-attribute">font-size</span>: <span class="hljs-variable">$font</span>-size-l-<span class="hljs-number">2</span>    <span class="hljs-attribute">line-height</span>: <span class="hljs-variable">$line</span>-height-l-<span class="hljs-number">2</span>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> n == <span class="hljs-string">'l-3'</span>    <span class="hljs-attribute">font-size</span>: <span class="hljs-variable">$font</span>-size-l-<span class="hljs-number">3</span>    <span class="hljs-attribute">line-height</span>: <span class="hljs-variable">$line</span>-height-l-<span class="hljs-number">3</span></code></pre></p><p><strong>色彩</strong><br>官方提供了6种可配置的颜色，都是大自然的颜色！灵感来源就是大自然啊。如果你一个都不喜欢，那就自己去代码里面改了。<br><pre><code class="hljs bash"><span class="hljs-comment"># theme color</span>main_color: default <span class="hljs-comment"># forest | grass | sky | sun | sea</span></code></pre></p><p><img src="https://source-hosting.oss-cn-shanghai.aliyuncs.com/paper-github-4.png" alt></p><p><strong>对于自己设计的评价(tu cao)</strong></p><ul><li>拼命想设计出paper的感觉，但是又不够paper。心有余而力不足，设计能力还是欠佳。</li><li>字体没有好好的琢磨，采用了比较通用的方案。导致整体设计缺少精致感。</li><li>阅读体验不够好，比如没有目录等等。精力有限，后续可能会加上。</li><li>…</li></ul><h3 id="编码部分"><a href="#编码部分" class="headerlink" title="编码部分"></a>编码部分</h3><p><strong>hexo主题的开发</strong><br>其实设计才是最难的部分，编码反而简单，只是有点“烦人”。因为开发hexo的主题，用的是以前的前端开发方式——写模版。对我来说，还是第一次写这种模版，而我已经习惯了基于vue、react的单页面开发模式。所以会感觉比较“烦人”。不过其中有很多思想也是相似的，例如，组件化的思想。</p><p>hexo主题的开发，网络上已经有很多相关的文章，我也没必要再说一遍。这里推荐一篇博客，几乎涵盖了所有开发相关的问题。</p><blockquote><p><a href="https://molunerfinn.com/make-a-hexo-theme/" target="_blank" rel="noopener">https://molunerfinn.com/make-a-hexo-theme/</a></p></blockquote><p><strong>darkmode</strong><br>开启的地方在这：<br><img src="https://source-hosting.oss-cn-shanghai.aliyuncs.com/20191214193636.png" alt><br>这里算是一个小彩蛋，具体的实现方式可以到代码里面去看，就几十行。<br>不过可以告知的是，<strong>我并没有</strong>修改页面中元素自身的css。例如字体颜色<code>color</code>，我并没有去修改这个属性。而是给全局加了个“滤镜”。</p><p>我个人认为这个方法还是比较巧妙的。其实就是一种偷懒的行为，因为我不想再去单独的针对darkmode设计多套配色。加一层“滤镜”可以在偷懒和效果之间达到一种比较好的平衡。效果肯定是比不上针对darkmode去重新搭配颜色的，但是也还过得去，不是吗。</p><p>其实关于编码部分，真的没有太多的感悟，就是照着自己的设计去一点点实现。</p><h3 id="btw"><a href="#btw" class="headerlink" title="btw"></a>btw</h3><p>最后，如果你真的觉得paper不错，那还是欢迎使用，再过分一点还可以点赞。但是我要提醒你，它真的不太好“用”😂，后面有时间再优化吧。具体使用相关的信息可以在<a href="https://github.com/OfficialYoungX/paper" target="_blank" rel="noopener">github</a>上找到。</p><p>这篇文章除了介绍自己好不容易完成的主题以外，还是想告诉大家，下次找不到自己觉得好看的主题，不如试试自己的写一个。过程是挺烦的，但是最后完成了还是开心的。不管它有没有人用，别人觉得怎么样，自己看到都会很有成就感。毕竟就算是只有你一个人用你自己的主题，那你的博客主题就是独一无二的啊。</p><p><img src="https://source-hosting.oss-cn-shanghai.aliyuncs.com/article-tail@3x.png" alt="tail"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://source-hosting.oss-cn-shanghai.aliyuncs.com/Paper-showcase.png&quot; alt&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;虽然麻烦，但是我还是写了个自己的博客主题叫&lt;a hre
      
    
    </summary>
    
    
    
      <category term="design" scheme="http://www.randomyang.top/tags/design/"/>
    
      <category term="blog主题" scheme="http://www.randomyang.top/tags/blog%E4%B8%BB%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>[译]使用Three.js制作有粘稠感的图像悬停效果</title>
    <link href="http://www.randomyang.top/2019/11/02/%E8%AF%91-%E4%BD%BF%E7%94%A8Three-js%E5%88%B6%E4%BD%9CGooey%E5%9B%BE%E5%83%8F%E6%82%AC%E5%81%9C%E6%95%88%E6%9E%9C/"/>
    <id>http://www.randomyang.top/2019/11/02/%E8%AF%91-%E4%BD%BF%E7%94%A8Three-js%E5%88%B6%E4%BD%9CGooey%E5%9B%BE%E5%83%8F%E6%82%AC%E5%81%9C%E6%95%88%E6%9E%9C/</id>
    <published>2019-11-02T14:40:02.000Z</published>
    <updated>2020-03-08T05:21:46.414Z</updated>
    
    <content type="html"><![CDATA[<h1 id="译-使用Three-js制作有粘稠感的图像悬停效果"><a href="#译-使用Three-js制作有粘稠感的图像悬停效果" class="headerlink" title="[译]使用Three.js制作有粘稠感的图像悬停效果"></a>[译]使用Three.js制作有粘稠感的图像悬停效果</h1><blockquote><p>原文链接：<a href="https://tympanus.net/codrops/2019/10/23/making-gooey-image-hover-effects-with-three-js/" target="_blank" rel="noopener">https://tympanus.net/codrops/2019/10/23/making-gooey-image-hover-effects-with-three-js/</a></p></blockquote><p><strong>学习如何使用噪声在着色器中创建粘稠的悬停效果。</strong></p><p><img src="https://source-hosting.oss-cn-shanghai.aliyuncs.com/ThumbnailGooeyHoverEffect.jpg" alt="ThumbnailGooeyHoverEffect"></p><p><a href="https://tympanus.net/Tutorials/GooeyImageHoverEffects/" target="_blank" rel="noopener">查看在线演示</a>or<a href="https://github.com/Aqro/gooey-hover-codrops" target="_blank" rel="noopener">下载源码</a></p><p>作为Flash的替代者WebGL在近几年随着像Three.js, PIXI.js, OGL.js这样的库而变得越来越火。它们对于创建<em>空白板</em>非常有用，唯一的限制只有你的想象力。我们看到越来越多的WebGL创建的效果微妙地集成到交互界面中，以进行悬停，滚动或显示效果。比如 <a href="https://www.hellomonday.com/" target="_blank" rel="noopener">Hello Monday</a> 或者是 <a href="https://www.cobosrl.co/" target="_blank" rel="noopener">cobosrl.co</a>.</p><p>在本教程中，我们将使用Three.js创建特殊的粘稠纹理，将其用于在悬停时显示另一幅图像。你现在就可以点击演示链接，去看看真实的效果！对于演示本身，我创建了一个更实际的示例，该示例显示了带有图像的水平可滚动布局，其中每个图像都有不同的效果。你可以单击图像，它将变换为更大的版本，同时显示一些其他内容（Mock出的内容）。我们将会带你了解这个效果最有趣的部分，这样你就可以知道它是如何工作的，并且可以自己创建更多的效果！</p><p>我假设你对Javascript, Three.js以及着色器有一定的了解。如果你不了解，那么你可以先看看 <a href="https://threejs.org/docs/" target="_blank" rel="noopener">Three.js documentation</a>, <a href="https://thebookofshaders.com/" target="_blank" rel="noopener">The Book of Shaders</a>, <a href="https://threejsfundamentals.org/" target="_blank" rel="noopener">Three.js Fundamentals</a> 或者 <a href="https://discoverthreejs.com/book/contents/" target="_blank" rel="noopener">Discover Three.js</a>.</p><blockquote><p><strong>注意:</strong>本教程涵盖了许多部分。如果愿意，可以跳过HTML / CSS / JavaScript部分，直接转到着色器部分。</p></blockquote><h2 id="在-DOM-中创建场景-scene"><a href="#在-DOM-中创建场景-scene" class="headerlink" title="在 DOM 中创建场景(scene)"></a>在 DOM 中创建场景(scene)</h2><p>在我们创建有趣的东西之前，需要在HTML中插入图片。在HTML / CSS中设置初始位置和尺寸，比在JavaScript中定位所有内容更容易处理场景大小。此外，样式部分应该只在CSS中定义，而不要在Javascript中。例如，如果我们的图片在桌面端的比例为16：9，而在移动设备上的比例为4：3，我们只应该使用CSS来处理。 JavaScript将仅用于请求更新数据。</p><pre><code class="hljs html">// index.html<span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">article</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"tile"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">figure</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"tile__figure"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">"path/to/my/image.jpg"</span> <span class="hljs-attr">data-hover</span>=<span class="hljs-string">"path/to/my/hover-image.jpg"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"tile__image"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">"My image"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"400"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"300"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">figure</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">canvas</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"stage"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span></code></pre><pre><code class="hljs css">// style.css.container &#123;display: flex;align-items: center;justify-content: center;width: 100%;height: 100vh;z-index: 10;&#125;.tile &#123;width: 35vw;flex: 0 0 auto;&#125;.tile__image &#123;width: 100%;height: 100%;object-fit: cover;object-position: center;&#125;canvas &#123;position: fixed;left: 0;top: 0;width: 100%;height: 100vh;z-index: 9;&#125;</code></pre><p>正如你在上面看到的，我们已经创建了一个位于在屏幕居中的图像。稍后我们将利用data-src和data-hover属性，通过延迟加载在脚本中加载这两个图像。</p><p><a href="https://codesandbox.io/embed/step-00-xhkcr" target="_blank" rel="noopener"><img src="https://codesandbox.io/static/img/play-codesandbox.svg" alt="标签用法"></a></p><h2 id="在-JavaScript-中创建场景-scene"><a href="#在-JavaScript-中创建场景-scene" class="headerlink" title="在 JavaScript 中创建场景(scene)"></a>在 JavaScript 中创建场景(scene)</h2><p>让我们从不那么容易但也不算难的部分开始吧！首先，我们将创建场景，灯光和渲染器。</p><pre><code class="hljs js"><span class="hljs-comment">// Scene.js</span><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> THREE <span class="hljs-keyword">from</span> <span class="hljs-string">'three'</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Scene</span> </span>&#123;<span class="hljs-keyword">constructor</span>() &#123;<span class="hljs-keyword">this</span>.container = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'stage'</span>)<span class="hljs-keyword">this</span>.scene = <span class="hljs-keyword">new</span> THREE.Scene()<span class="hljs-keyword">this</span>.renderer = <span class="hljs-keyword">new</span> THREE.WebGLRenderer(&#123;<span class="hljs-attr">canvas</span>: <span class="hljs-keyword">this</span>.container,<span class="hljs-attr">alpha</span>: <span class="hljs-literal">true</span>,  &#125;)<span class="hljs-keyword">this</span>.renderer.setSize(<span class="hljs-built_in">window</span>.innerWidth, <span class="hljs-built_in">window</span>.innerHeight)<span class="hljs-keyword">this</span>.renderer.setPixelRatio(<span class="hljs-built_in">window</span>.devicePixelRatio)<span class="hljs-keyword">this</span>.initLights()&#125;initLights() &#123;<span class="hljs-keyword">const</span> ambientlight = <span class="hljs-keyword">new</span> THREE.AmbientLight(<span class="hljs-number">0xffffff</span>, <span class="hljs-number">2</span>)<span class="hljs-keyword">this</span>.scene.add(ambientlight)&#125;&#125;</code></pre><p>这是一个非常基本的场景。但是我们在场景中还需要一个基本的元素：相机。我们有两种可以供选择的相机：正射或透视。如果我们想让图片保持形状不变，我们可以选择第一种。但是对于旋转效果，我们希望在移动鼠标时具有一定的透视效果。</p><p>在带有透视相机的Three.js（或者其他用于WebGL的库）中，屏幕上的10个单位值并不等于10px。因此，这里的技巧是使用一些数学运算将1单位转换为1px，并更改视角以增加或减少失真效果。</p><pre><code class="hljs js"><span class="hljs-comment">// Scene.js</span><span class="hljs-keyword">const</span> perspective = <span class="hljs-number">800</span><span class="hljs-keyword">constructor</span>() &#123;<span class="hljs-comment">// ...</span><span class="hljs-keyword">this</span>.initCamera()&#125;initCamera() &#123;<span class="hljs-keyword">const</span> fov = (<span class="hljs-number">180</span> * (<span class="hljs-number">2</span> * <span class="hljs-built_in">Math</span>.atan(<span class="hljs-built_in">window</span>.innerHeight / <span class="hljs-number">2</span> / perspective))) / <span class="hljs-built_in">Math</span>.PI<span class="hljs-keyword">this</span>.camera = <span class="hljs-keyword">new</span> THREE.PerspectiveCamera(fov, <span class="hljs-built_in">window</span>.innerWidth / <span class="hljs-built_in">window</span>.innerHeight, <span class="hljs-number">1</span>, <span class="hljs-number">1000</span>)<span class="hljs-keyword">this</span>.camera.position.set(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, perspective)&#125;</code></pre><p>我们将透视值设置为800，以便在旋转平面时不会产生太大的变形。我们增加的视角越大，我们对扭曲的感知就越少，反之亦然。然后，我们需要做的最后一件事是在每一帧中渲染场景。</p><pre><code class="hljs js"><span class="hljs-comment">// Scene.js</span><span class="hljs-keyword">constructor</span>() &#123;<span class="hljs-comment">// ...</span><span class="hljs-keyword">this</span>.update()&#125;update() &#123;requestAnimationFrame(<span class="hljs-keyword">this</span>.update.bind(<span class="hljs-keyword">this</span>))<span class="hljs-keyword">this</span>.renderer.render(<span class="hljs-keyword">this</span>.scene, <span class="hljs-keyword">this</span>.camera)&#125;</code></pre><p>如果你的屏幕不是黑色的，则说明方法正确！</p><h2 id="用正确的尺寸创建平面"><a href="#用正确的尺寸创建平面" class="headerlink" title="用正确的尺寸创建平面"></a>用正确的尺寸创建平面</h2><p>如上所述，我们必须从DOM中的图像上检索一些其他信息，例如其尺寸和在页面上的位置。</p><pre><code class="hljs js"><span class="hljs-comment">// Scene.js</span><span class="hljs-keyword">import</span> Figure <span class="hljs-keyword">from</span> <span class="hljs-string">'./Figure'</span><span class="hljs-keyword">constructor</span>() &#123;<span class="hljs-comment">// ...</span><span class="hljs-keyword">this</span>.figure = <span class="hljs-keyword">new</span> Figure(<span class="hljs-keyword">this</span>.scene)&#125;</code></pre><pre><code class="hljs js"><span class="hljs-comment">// Figure.js</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Figure</span> </span>&#123;<span class="hljs-keyword">constructor</span>(scene) &#123;<span class="hljs-keyword">this</span>.$image = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.tile__image'</span>)<span class="hljs-keyword">this</span>.scene = scene<span class="hljs-keyword">this</span>.loader = <span class="hljs-keyword">new</span> THREE.TextureLoader()<span class="hljs-keyword">this</span>.image = <span class="hljs-keyword">this</span>.loader.load(<span class="hljs-keyword">this</span>.$image.dataset.src)<span class="hljs-keyword">this</span>.hoverImage = <span class="hljs-keyword">this</span>.loader.load(<span class="hljs-keyword">this</span>.$image.dataset.hover)<span class="hljs-keyword">this</span>.sizes = <span class="hljs-keyword">new</span> THREE.Vector2(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<span class="hljs-keyword">this</span>.offset = <span class="hljs-keyword">new</span> THREE.Vector2(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<span class="hljs-keyword">this</span>.getSizes()<span class="hljs-keyword">this</span>.createMesh()&#125;&#125;</code></pre><p>首先，我们创建另一个类，将场景作为属性传递给该类。我们设置了两个新的矢量，尺寸和偏移，用于存储DOM图像的尺寸和位置。</p><p>此外，我们将使用TextureLoader来“加载”图像并将其转换为纹理。我们需要这样做，因为我们想在着色器中使用这些图片。</p><p>我们需要在类中创建一个方法来处理图像的加载并等待回调。我们可以使用异步功能来实现这一目标，但对于本教程而言，我们将其保持简单。请记住，您可能需要出于自身目的对它进行一些重构。</p><pre><code class="hljs js"><span class="hljs-comment">// Figure.js</span><span class="hljs-comment">// ...</span>getSizes() &#123;<span class="hljs-keyword">const</span> &#123; width, height, top, left &#125; = <span class="hljs-keyword">this</span>.$image.getBoundingClientRect()<span class="hljs-keyword">this</span>.sizes.set(width, height)<span class="hljs-keyword">this</span>.offset.set(left - <span class="hljs-built_in">window</span>.innerWidth / <span class="hljs-number">2</span> + width / <span class="hljs-number">2</span>, -(top - <span class="hljs-built_in">window</span>.innerHeight / <span class="hljs-number">2</span> + height / <span class="hljs-number">2</span>))&#125;<span class="hljs-comment">// ...</span></code></pre><p>我们在getBoundingClientRect对象中获取图像信息。然后，将它们传递给两个变量。这里的偏移量用于计算屏幕中心与页面上的对象之间的距离。(译者：可以补充解释)</p><pre><code class="hljs js"><span class="hljs-comment">// Figure.js</span><span class="hljs-comment">// ...</span>createMesh() &#123;<span class="hljs-keyword">this</span>.geometry = <span class="hljs-keyword">new</span> THREE.PlaneBufferGeometry(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<span class="hljs-keyword">this</span>.material = <span class="hljs-keyword">new</span> THREE.MeshBasicMaterial(&#123;<span class="hljs-attr">map</span>: <span class="hljs-keyword">this</span>.image&#125;)<span class="hljs-keyword">this</span>.mesh = <span class="hljs-keyword">new</span> THREE.Mesh(<span class="hljs-keyword">this</span>.geometry, <span class="hljs-keyword">this</span>.material)<span class="hljs-keyword">this</span>.mesh.position.set(<span class="hljs-keyword">this</span>.offset.x, <span class="hljs-keyword">this</span>.offset.y, <span class="hljs-number">0</span>)<span class="hljs-keyword">this</span>.mesh.scale.set(<span class="hljs-keyword">this</span>.sizes.x, <span class="hljs-keyword">this</span>.sizes.y, <span class="hljs-number">1</span>)<span class="hljs-keyword">this</span>.scene.add(<span class="hljs-keyword">this</span>.mesh)&#125;<span class="hljs-comment">// ...</span></code></pre><p>之后，我们将在平面上设置值。如您所见，我们在1px上创建了一个平面，该平面上有1行1列。由于我们<em>不想</em>使平面变形，所以我们不需要很多面或顶点。因此，让我们保持简单。</p><p>既然我们可以直接设置网格的大小，为什么要用缩放的方式来实现？</p><p>其实这么做主要是为了更加便于调整网格的大小。如果我们之后要更改网格的大小，除了用scale没有什么更好的方法。虽然更改网格的比例更容易直接实现，但是用来调整尺寸并不太方便。（译者：作者这里其实是一个很巧妙的做法：直接将原来的大小设置为1x1，然后采用缩放API来让网格变换为实际大小，这样缩放的比例也就等于实际的长宽值）</p><p>目前，我们设置了MeshBasicMaterial，看来一切正常。</p><h2 id="获取鼠标坐标"><a href="#获取鼠标坐标" class="headerlink" title="获取鼠标坐标"></a>获取鼠标坐标</h2><p>现在，我们已经使用网格构建了场景，我们想要获取鼠标坐标，并且为了使事情变得简单，我们将其<strong>归一化</strong>。为什么要归一化？看看着色器的坐标系统你就明白了。</p><p><img src="https://source-hosting.oss-cn-shanghai.aliyuncs.com/coordinate-system.jpg" alt></p><p>如上图所示，我们已经将两个着色器的值标准化了。为简单起见，我们将转化鼠标坐标以匹配顶点着色器坐标。</p><p>如果你在这里觉得理解有困难, 我建议你去看一看 <a href="https://thebookofshaders.com/" target="_blank" rel="noopener">Book of Shaders</a> 和 <a href="https://threejsfundamentals.org/" target="_blank" rel="noopener">Three.js Fundamentals</a>的各个章节。 两者都有很好的建议，并提供了许多示例来帮助你理解。</p><pre><code class="hljs js"><span class="hljs-comment">// Figure.js</span><span class="hljs-comment">// ...</span><span class="hljs-keyword">this</span>.mouse = <span class="hljs-keyword">new</span> THREE.Vector2(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'mousemove'</span>, (ev) =&gt; &#123; <span class="hljs-keyword">this</span>.onMouseMove(ev) &#125;)<span class="hljs-comment">// ...</span>onMouseMove(event) &#123;TweenMax.to(<span class="hljs-keyword">this</span>.mouse, <span class="hljs-number">0.5</span>, &#123;<span class="hljs-attr">x</span>: (event.clientX / <span class="hljs-built_in">window</span>.innerWidth) * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>,<span class="hljs-attr">y</span>: -(event.clientY / <span class="hljs-built_in">window</span>.innerHeight) * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>,&#125;)TweenMax.to(<span class="hljs-keyword">this</span>.mesh.rotation, <span class="hljs-number">0.5</span>, &#123;<span class="hljs-attr">x</span>: -<span class="hljs-keyword">this</span>.mouse.y * <span class="hljs-number">0.3</span>,<span class="hljs-attr">y</span>: <span class="hljs-keyword">this</span>.mouse.x * (<span class="hljs-built_in">Math</span>.PI / <span class="hljs-number">6</span>)&#125;)&#125;</code></pre><p>对于补间部分，我将使用GreenSock的TweenMax。这是有史以来最好的库。而且非常适合我们想要达到的目的。我们不需要处理两个状态之间的转换，TweenMax会为我们完成。每次移动鼠标时，TweenMax都会平滑更新位置坐标和旋转角度。</p><p><a href="https://codesandbox.io/s/step-01-uozmf?from-embed" target="_blank" rel="noopener"><img src="https://codesandbox.io/static/img/play-codesandbox.svg" alt="标签用法"></a></p><p>在进行后面的步骤之前还有一件事：我们将材质从MeshBasicMaterial更新为ShaderMaterial，并传递一些值（均匀值）和着色器代码。</p><pre><code class="hljs js"><span class="hljs-comment">// Figure.js</span><span class="hljs-comment">// ...</span><span class="hljs-keyword">this</span>.uniforms = &#123;<span class="hljs-attr">u_image</span>: &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">'t'</span>, <span class="hljs-attr">value</span>: <span class="hljs-keyword">this</span>.image &#125;,<span class="hljs-attr">u_imagehover</span>: &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">'t'</span>, <span class="hljs-attr">value</span>: <span class="hljs-keyword">this</span>.hover &#125;,<span class="hljs-attr">u_mouse</span>: &#123; <span class="hljs-attr">value</span>: <span class="hljs-keyword">this</span>.mouse &#125;,<span class="hljs-attr">u_time</span>: &#123; <span class="hljs-attr">value</span>: <span class="hljs-number">0</span> &#125;,<span class="hljs-attr">u_res</span>: &#123; <span class="hljs-attr">value</span>: <span class="hljs-keyword">new</span> THREE.Vector2(<span class="hljs-built_in">window</span>.innerWidth, <span class="hljs-built_in">window</span>.innerHeight) &#125;&#125;<span class="hljs-keyword">this</span>.material = <span class="hljs-keyword">new</span> THREE.ShaderMaterial(&#123;<span class="hljs-attr">uniforms</span>: <span class="hljs-keyword">this</span>.uniforms,<span class="hljs-attr">vertexShader</span>: vertexShader,<span class="hljs-attr">fragmentShader</span>: fragmentShader&#125;)update() &#123;<span class="hljs-keyword">this</span>.uniforms.u_time.value += <span class="hljs-number">0.01</span>&#125;</code></pre><p>我们传递了两个纹理，以及鼠标的位置，屏幕的大小和一个名为<code>u_time</code>的变量，该变量将在每一帧进行递增。</p><p>但是请记住，这不是最好的方法。我们只需要当我们将鼠标悬停在图形上时增加，而不必在每一帧上增加。出于性能，最好仅在需要时更新着色器。</p><h2 id="技巧背后的原理及如何使用噪声"><a href="#技巧背后的原理及如何使用噪声" class="headerlink" title="技巧背后的原理及如何使用噪声"></a>技巧背后的原理及如何使用噪声</h2><p>我不会解释什么是噪声以及噪声的来源。如果你有兴趣，请探究《 The Shader of Shaders》中的<a href="https://thebookofshaders.com/11/" target="_blank" rel="noopener">相关章节</a>，它进行了很好的解释。</p><p>长话短说，噪声是一个函数，它根据传递的值为我们提供介于-1和1之间的值。它将输出随机但却又相关的值。</p><p>多亏了噪声，我们才能生成许多不同的形状，例如地图，随机图案等。</p><p><img src="https://source-hosting.oss-cn-shanghai.aliyuncs.com/noise-example1-e1570735927299.jpg" alt><br><img src="https://source-hosting.oss-cn-shanghai.aliyuncs.com/noise-example2-e1570735958909.jpg" alt></p><p>让我们从2D噪声开始。仅通过传递纹理的坐标，我们就可以得到类似云的纹理。</p><p><img src="https://source-hosting.oss-cn-shanghai.aliyuncs.com/noise-result1.jpg" alt></p><p>但事实上有好几种噪声函数。我们使用3D噪声，再给一个参数，例如…时间？噪声图形将随着时间的流逝而变化。通过更改频率和幅度，我们可以进行一些变化并增加对比度。</p><p><img src="https://source-hosting.oss-cn-shanghai.aliyuncs.com/noise-result2.jpg" alt></p><p>其次，我们将创建一个圆。在片段着色器中构建像圆形这样的简单形状非常容易。我们只是采用了《 The Shader of Shaders：Shapes》中的功能来创建一个模糊的圆，增加对比度和视觉效果！</p><p><img src="https://source-hosting.oss-cn-shanghai.aliyuncs.com/noise-result3.jpg" alt></p><p>最后，我们将这两个加在一起，使用一些变量，让它对纹理进行“切片”：</p><p><img src="https://source-hosting.oss-cn-shanghai.aliyuncs.com/noise-result4-e1570736096227.jpg" alt></p><p>这个混合之后的结果是不是很让人兴奋，让我们深入到代码层面继续探究！</p><h2 id="着色器"><a href="#着色器" class="headerlink" title="着色器"></a>着色器</h2><p>我们这里确实不需要顶点着色器，这是我们的代码：</p><pre><code class="hljs glsl"> <span class="hljs-comment">// vertexShader.glsl</span><span class="hljs-keyword">varying</span> <span class="hljs-type">vec2</span> v_uv;<span class="hljs-type">void</span> main() &#123;v_uv = uv;<span class="hljs-built_in">gl_Position</span> = projectionMatrix * modelViewMatrix * <span class="hljs-type">vec4</span>(position, <span class="hljs-number">1.0</span>);&#125;</code></pre><p>Three.js的ShaderMaterial提供了一些有用的默认变量，便于初学者使用：</p><ul><li>位置（vec3）：网格每个顶点的坐标</li><li>uv（vec2）：纹理的坐标</li><li>法线（vec3）：网格中每个顶点的法线。</li></ul><p>在这里，我们只是将UV坐标从顶点着色器传递到片段着色器。</p><h2 id="创建圆形"><a href="#创建圆形" class="headerlink" title="创建圆形"></a>创建圆形</h2><p>让我们使用 <a href="https://thebookofshaders.com/07/" target="_blank" rel="noopener">The Book of Shaders</a>中的函数来构建圆并添加一个变量来控制边缘的模糊性。</p><p>此外，我们将用鼠标位置来同步圆心坐标。这样，只要我们将鼠标移到图像上，圆就会跟随鼠标移动。</p><pre><code class="hljs glsl"><span class="hljs-comment">// fragmentShader.glsl</span><span class="hljs-keyword">uniform</span> <span class="hljs-type">vec2</span> u_mouse;<span class="hljs-keyword">uniform</span> <span class="hljs-type">vec2</span> u_res;<span class="hljs-type">float</span> circle(<span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> _st, <span class="hljs-keyword">in</span> <span class="hljs-type">float</span> _radius, <span class="hljs-keyword">in</span> <span class="hljs-type">float</span> blurriness)&#123;<span class="hljs-type">vec2</span> dist = _st;<span class="hljs-keyword">return</span> <span class="hljs-number">1.</span>-<span class="hljs-built_in">smoothstep</span>(_radius-(_radius*blurriness), _radius+(_radius*blurriness), <span class="hljs-built_in">dot</span>(dist,dist)*<span class="hljs-number">4.0</span>);&#125;<span class="hljs-type">void</span> main() &#123;<span class="hljs-type">vec2</span> st = <span class="hljs-built_in">gl_FragCoord</span>.xy / u_res.xy - <span class="hljs-type">vec2</span>(<span class="hljs-number">1.</span>);<span class="hljs-comment">// tip: use the following formula to keep the good ratio of your coordinates</span>st.y *= u_res.y / u_res.x;<span class="hljs-type">vec2</span> mouse = u_mouse;<span class="hljs-comment">// tip2: do the same for your mouse</span>mouse.y *= u_res.y / u_res.x;mouse *= <span class="hljs-number">-1.</span>;<span class="hljs-type">vec2</span> circlePos = st + mouse;<span class="hljs-type">float</span> c = circle(circlePos, <span class="hljs-number">.03</span>, <span class="hljs-number">2.</span>);<span class="hljs-built_in">gl_FragColor</span> = <span class="hljs-type">vec4</span>(<span class="hljs-type">vec3</span>(c), <span class="hljs-number">1.</span>);&#125;</code></pre><p><a href="https://codesandbox.io/embed/step-02-engiv" target="_blank" rel="noopener"><img src="https://codesandbox.io/static/img/play-codesandbox.svg" alt="标签用法"></a></p><h2 id="创建一些噪噪噪噪声声声～～"><a href="#创建一些噪噪噪噪声声声～～" class="headerlink" title="创建一些噪噪噪噪声声声～～"></a>创建一些噪噪噪噪声声声～～</h2><p>正如我们在上面看到的，噪声函数具有多个参数，并为我们生成了逼真的云图案。那么我们是如何得到的呢？</p><p>对于这一部分，我将使用<a href="https://www.npmjs.com/package/glslify" target="_blank" rel="noopener">glslify</a>和<a href="https://www.npmjs.com/package/glsl-noise" target="_blank" rel="noopener">glsl-noise</a>，以及两个npm包来包含其他功能。它使我们的着色器更具可读性，并且隐藏了很多我们根本不会使用的显示函数。</p><pre><code class="hljs glsl"><span class="hljs-comment">// fragmentShader.glsl</span><span class="hljs-meta">#pragma glslify: snoise2 = require('glsl-noise/simplex/2d')</span><span class="hljs-comment">//...</span><span class="hljs-keyword">varying</span> <span class="hljs-type">vec2</span> v_uv;<span class="hljs-keyword">uniform</span> <span class="hljs-type">float</span> u_time;<span class="hljs-type">void</span> main() &#123;<span class="hljs-comment">// ...</span><span class="hljs-type">float</span> n = snoise2(<span class="hljs-type">vec2</span>(v_uv.x, v_uv.y));<span class="hljs-built_in">gl_FragColor</span> = <span class="hljs-type">vec4</span>(<span class="hljs-type">vec3</span>(n), <span class="hljs-number">1.</span>);&#125;</code></pre><p><img src="https://source-hosting.oss-cn-shanghai.aliyuncs.com/noise-result5.jpg" alt></p><p>通过更改噪声的幅度和频率（比如于sin / cos函数），我们可以更改渲染。</p><pre><code class="hljs glsl"><span class="hljs-comment">// fragmentShader.glsl</span><span class="hljs-type">float</span> offx = v_uv.x + <span class="hljs-built_in">sin</span>(v_uv.y + u_time * <span class="hljs-number">.1</span>);<span class="hljs-type">float</span> offy = v_uv.y - u_time * <span class="hljs-number">0.1</span> - <span class="hljs-built_in">cos</span>(u_time * <span class="hljs-number">.001</span>) * <span class="hljs-number">.01</span>;<span class="hljs-type">float</span> n = snoise2(<span class="hljs-type">vec2</span>(offx, offy) * <span class="hljs-number">5.</span>) * <span class="hljs-number">1.</span>;</code></pre><p><img src="https://source-hosting.oss-cn-shanghai.aliyuncs.com/noise-result6.jpg" alt></p><p>但这并时间的函数！它失真了，我们想要出色的效果。因此，我们将改为使用noise3d并传递第三个参数：时间。</p><pre><code class="hljs glsl"><span class="hljs-type">float</span> n = snoise3(<span class="hljs-type">vec3</span>(offx, offy, u_time * <span class="hljs-number">.1</span>) * <span class="hljs-number">4.</span>) * <span class="hljs-number">.5</span>;</code></pre><h2 id="合并纹理"><a href="#合并纹理" class="headerlink" title="合并纹理"></a>合并纹理</h2><p>只要将它们叠加在一起，我们就可以看到随时间变化的有趣的形状。</p><p><img src="https://source-hosting.oss-cn-shanghai.aliyuncs.com/noise-result7.jpg" alt></p><p>为了解释其背后的原理，让我们假设噪声就像是在-1和1之间浮动的值。但是我们的屏幕无法显示负值或大于1（纯白色）的像素，因此我们只能看到0到1之间的值。</p><p><img src="https://source-hosting.oss-cn-shanghai.aliyuncs.com/explanation-noise1.jpg" alt></p><p>我们的圆形则像这样：</p><p><img src="https://source-hosting.oss-cn-shanghai.aliyuncs.com/explanation-noise2.jpg" alt></p><p>相加之后的近似结果：</p><p><img src="https://source-hosting.oss-cn-shanghai.aliyuncs.com/explanation-noise3.jpg" alt></p><p>我们非常白的像素是可见光谱之外的像素。</p><p>如果我们减小噪声并减去少量噪声，它将逐渐沿波浪向下移动，直到其消失在可见颜色的范围之内。</p><p><img src="https://source-hosting.oss-cn-shanghai.aliyuncs.com/noise-result8.jpg" alt></p><pre><code class="hljs glsl"><span class="hljs-type">float</span> n = snoise(<span class="hljs-type">vec3</span>(offx, offy, u_time * <span class="hljs-number">.1</span>) * <span class="hljs-number">4.</span>) - <span class="hljs-number">1.</span>;</code></pre><p>我们的圆形仍然存在，只是可见度比较低。如果我们增加乘以它的值，它将形成更大的对比。</p><pre><code class="hljs glsl"><span class="hljs-type">float</span> c = circle(circlePos, <span class="hljs-number">0.3</span>, <span class="hljs-number">0.3</span>) * <span class="hljs-number">2.5</span>;</code></pre><p><img src="https://source-hosting.oss-cn-shanghai.aliyuncs.com/noise-result9.jpg" alt></p><p>我们就实现我们最想要的效果了！但是正如你看到的，仍然缺少一些细节。而且我们的边缘一点也不锐利。</p><p>为了解决这个问题，我们将使用 <a href="https://thebookofshaders.com/glossary/?search=smoothstep" target="_blank" rel="noopener">built-in smoothstep function</a>。</p><pre><code class="hljs glsl"><span class="hljs-type">float</span> finalMask = <span class="hljs-built_in">smoothstep</span>(<span class="hljs-number">0.4</span>, <span class="hljs-number">0.5</span>, n + c);<span class="hljs-built_in">gl_FragColor</span> = <span class="hljs-type">vec4</span>(<span class="hljs-type">vec3</span>(finalMask), <span class="hljs-number">1.</span>);</code></pre><p>借助此功能，我们将在0.4到0.5之间切出一部分图案。这些值之间的间隔越短，边缘越锐利。</p><p><a href="https://codesandbox.io/embed/step-03-xpfc8" target="_blank" rel="noopener"><img src="https://codesandbox.io/static/img/play-codesandbox.svg" alt="标签用法"></a></p><p>最后，我们可以将混合两个纹理用作遮罩。</p><pre><code class="hljs glsl"><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> u_image;<span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> u_imagehover;<span class="hljs-comment">// ...</span><span class="hljs-type">vec4</span> image = <span class="hljs-built_in">texture2D</span>(u_image, uv);<span class="hljs-type">vec4</span> hover = <span class="hljs-built_in">texture2D</span>(u_imagehover, uv);<span class="hljs-type">vec4</span> finalImage = <span class="hljs-built_in">mix</span>(image, hover, finalMask);<span class="hljs-built_in">gl_FragColor</span> = finalImage;</code></pre><p>我们可以更改一些变量以产生更强的粘稠效果：</p><pre><code class="hljs glsl"><span class="hljs-comment">// ...</span><span class="hljs-type">float</span> c = circle(circlePos, <span class="hljs-number">0.3</span>, <span class="hljs-number">2.</span>) * <span class="hljs-number">2.5</span>;<span class="hljs-type">float</span> n = snoise3(<span class="hljs-type">vec3</span>(offx, offy, u_time * <span class="hljs-number">.1</span>) * <span class="hljs-number">8.</span>) - <span class="hljs-number">1.</span>;<span class="hljs-type">float</span> finalMask = <span class="hljs-built_in">smoothstep</span>(<span class="hljs-number">0.4</span>, <span class="hljs-number">0.5</span>, n + <span class="hljs-built_in">pow</span>(c, <span class="hljs-number">2.</span>));<span class="hljs-comment">// ...</span></code></pre><p><a href="https://codesandbox.io/embed/step-04-9gyz8" target="_blank" rel="noopener"><img src="https://codesandbox.io/static/img/play-codesandbox.svg" alt="标签用法"></a></p><p>在这里可以找到<a href="https://github.com/Aqro/gooey-hover-codrops" target="_blank" rel="noopener">完整的源码</a></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>很高兴你能读到这。这篇教程并不完美，我可能忽略了一些细节，但是我希望你仍然喜欢本教程。基于此，你可以尽情的使用更多变量，尝试其他噪声函数，并尝试使用鼠标方向或滚动发挥你的想象力来实现其他效果！</p><h2 id="参考以及感谢"><a href="#参考以及感谢" class="headerlink" title="参考以及感谢"></a>参考以及感谢</h2><ul><li><a href="https://unsplash.com/" target="_blank" rel="noopener">Images from Unsplash</a></li><li><a href="https://threejs.org/docs/" target="_blank" rel="noopener">Three.js</a></li><li><a href="https://greensock.com/" target="_blank" rel="noopener">GSAP from GreenSock</a></li><li><a href="https://idiotwu.github.io/smooth-scrollbar/" target="_blank" rel="noopener">Smooth Scrollbar</a></li><li><a href="https://github.com/glslify/glslify" target="_blank" rel="noopener">glslify</a></li><li><a href="https://www.npmjs.com/package/glsl-noise" target="_blank" rel="noopener">glsl-noise</a></li></ul><p><img src="https://source-hosting.oss-cn-shanghai.aliyuncs.com/article-tail@3x.png" alt="tail"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;译-使用Three-js制作有粘稠感的图像悬停效果&quot;&gt;&lt;a href=&quot;#译-使用Three-js制作有粘稠感的图像悬停效果&quot; class=&quot;headerlink&quot; title=&quot;[译]使用Three.js制作有粘稠感的图像悬停效果&quot;&gt;&lt;/a&gt;[译]使用Three
      
    
    </summary>
    
    
    
      <category term="Graphic" scheme="http://www.randomyang.top/tags/Graphic/"/>
    
      <category term="glsl" scheme="http://www.randomyang.top/tags/glsl/"/>
    
      <category term="WebGL" scheme="http://www.randomyang.top/tags/WebGL/"/>
    
  </entry>
  
  <entry>
    <title>视差滚动-3D</title>
    <link href="http://www.randomyang.top/2019/06/08/%E6%BB%9A%E5%8A%A8%E8%A7%86%E5%B7%AE-3D/"/>
    <id>http://www.randomyang.top/2019/06/08/%E6%BB%9A%E5%8A%A8%E8%A7%86%E5%B7%AE-3D/</id>
    <published>2019-06-08T05:40:32.000Z</published>
    <updated>2020-03-06T12:35:10.068Z</updated>
    
    <content type="html"><![CDATA[<h1 id="视差滚动-3D"><a href="#视差滚动-3D" class="headerlink" title="视差滚动-3D"></a>视差滚动-3D</h1><p><img src="/2019/06/08/滚动视差-3D/屏幕录制 2019-06-08 14.15.13.gif" alt="屏幕录制 2019-06-08 14.15.13"></p><p><small>网址链接：<a href="https://ripple.com/xrp" target="_blank" rel="noopener">https://ripple.com/xrp</a></small></p><p>偶然间翻出一个之前收藏的网站，被开始的这个landing效果惊到了。我为什么会收藏这个网站？！我对他的业务似乎是没有丝毫兴趣，那我必定是被这炫酷（炫酷？）的视觉效果吸引了。</p><p>和通常看到的<strong>视差滚动</strong>（滑动相同距离相同，但不同的元素移动不同的距离）效果不同。当你用鼠标滚动时，它给人一种从桌面上到移动到桌面下的视觉效果。对我来说，应该是讲是第一次看到这种效果的视差滚动。</p><p>刚开始我猜测应该是在<code>canvas</code>中实现的，怀着我的猜想，我自信的按下了<code>option+command+I</code>！当打开console的一瞬间我惊了，不是<code>canvas</code>,完全没有，竟然是用<strong>div叠加</strong>而成的！</p><p><img src="/2019/06/08/滚动视差-3D/image-20190608142517838.png" alt="image-20190608142517838"></p><p>怀着好奇之心，我决定扒一扒背后的原理。</p><h3 id="扒原理"><a href="#扒原理" class="headerlink" title="扒原理"></a>扒原理</h3><p>总共6个不同的部分，分别为一个<code>div</code>，总的可以分为两个部分</p><ol><li>地面上的网 -&gt; 桌面（只有一个桌面，也就只有一个div）</li><li>地面上的物体 -&gt; 桌面上摆放的东西（5个div）</li></ol><p>随着鼠标的滑动</p><p>情况1.可以观察到css属性<code>scaleY(val)</code>中的val值在不断的变化，从正到负。</p><p>可以理解为随着滑动，将桌面对应的div进行Y方向的形变，正 -&gt; 0 -&gt; 负数，最终表现出的效果就是从桌面上移动到桌面下观察的效果。</p><p>情况2.可以观察到css属性<code>translate3d(x,y,z)</code>中的y值在不断的改变。但是每一个div的变化量是不一样的，越<strong>靠近</strong>屏幕的div变化量<strong>越大</strong>，越远则越小。可以参考<strong>prespective</strong>这个概念，这样在滑动的时候就表现出视差的效果。</p><p>总结：</p><p>桌面进行伸缩变换，桌面上的物体进行平移变换。两个效果叠加出<strong>3D效果的视差滚动</strong>。</p><p><img src="/2019/06/08/滚动视差-3D/变换示意图.png" alt="变换示意图"></p><h3 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h3><p>在知道了基本原理之后，发现其实并不难。想要做出这样的效果需要满足几个条件：</p><ol><li><p>设计师需要事先设计出具有类似3D效果的图形</p></li><li><p>导出的资源（这里指png图片）需要<strong>合理</strong>的分块，准切的来将是在Z轴上不同深度的图形需要分别导出</p></li><li>在滚动过程中，不同的深度的分块在平移速度上需要满足一定的关系（最基本需要满足近快-远慢），具体的可能需要一定的3d数学计算</li><li>同样”桌面”在进行伸缩变换的时候，其变换量也与滚动距离有一定的关系</li></ol><p>其中每一步都影响着最终呈现出的效果。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这篇文章只是一个初步的原理分析，并没有提到如何去在代码中确定分块的<strong>伸缩量</strong>以及<strong>平移速度</strong>等等。这些需要进一步的去研究思考。暂时还没有去推导不同分块之间的速度关系。<br>其实最最重要的是想法，仔细看来这原理也不难，主要只用到了两个css transform属性。但是让人觉得很巧妙，而且效果很好。很佩服设计出这种效果的设计师和实现这种效果的前端工程师。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;视差滚动-3D&quot;&gt;&lt;a href=&quot;#视差滚动-3D&quot; class=&quot;headerlink&quot; title=&quot;视差滚动-3D&quot;&gt;&lt;/a&gt;视差滚动-3D&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2019/06/08/滚动视差-3D/屏幕录制 2019-06-08 14.1
      
    
    </summary>
    
    
    
      <category term="parallax" scheme="http://www.randomyang.top/tags/parallax/"/>
    
      <category term="视差滚动" scheme="http://www.randomyang.top/tags/%E8%A7%86%E5%B7%AE%E6%BB%9A%E5%8A%A8/"/>
    
      <category term="3D" scheme="http://www.randomyang.top/tags/3D/"/>
    
      <category term="借鉴" scheme="http://www.randomyang.top/tags/%E5%80%9F%E9%89%B4/"/>
    
  </entry>
  
  <entry>
    <title>我在2019，找实习</title>
    <link href="http://www.randomyang.top/2019/03/31/%E6%88%91%E5%9C%A82019%EF%BC%8C%E6%89%BE%E5%AE%9E%E4%B9%A0/"/>
    <id>http://www.randomyang.top/2019/03/31/%E6%88%91%E5%9C%A82019%EF%BC%8C%E6%89%BE%E5%AE%9E%E4%B9%A0/</id>
    <published>2019-03-31T15:15:30.000Z</published>
    <updated>2020-03-06T05:05:44.064Z</updated>
    
    <content type="html"><![CDATA[<p>下面的内容是我在准备 2019 年实习的过程中的一些学习记录。不见得全是正确的结论，但总的来讲是参考了很多的相关资料。自己查漏补缺的同时也学到了不少新的东西。</p><p><strong><a href="pdf版.pdf">稍有排版的pdf</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;下面的内容是我在准备 2019 年实习的过程中的一些学习记录。不见得全是正确的结论，但总的来讲是参考了很多的相关资料。自己查漏补缺的同时也学到了不少新的东西。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;pdf版.pdf&quot;&gt;稍有排版的pdf&lt;/a&gt;&lt;/strong&gt;&lt;/
      
    
    </summary>
    
    
    
      <category term="总结" scheme="http://www.randomyang.top/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="实习" scheme="http://www.randomyang.top/tags/%E5%AE%9E%E4%B9%A0/"/>
    
      <category term="面试" scheme="http://www.randomyang.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="前端" scheme="http://www.randomyang.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>正了个则</title>
    <link href="http://www.randomyang.top/2019/03/31/%E6%AD%A3%E4%BA%86%E4%B8%AA%E5%88%99/"/>
    <id>http://www.randomyang.top/2019/03/31/%E6%AD%A3%E4%BA%86%E4%B8%AA%E5%88%99/</id>
    <published>2019-03-31T14:52:23.000Z</published>
    <updated>2020-03-08T05:22:54.222Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>参考</p><blockquote><p><a href="https://imweb.io/topic/56e804ef1a5f05dc50643106" target="_blank" rel="noopener">https://imweb.io/topic/56e804ef1a5f05dc50643106</a></p><p><a href="https://louiszhai.github.io/2016/06/13/regexp" target="_blank" rel="noopener">https://louiszhai.github.io/2016/06/13/regexp</a></p><p><a href="https://regex101.com" target="_blank" rel="noopener">https://regex101.com</a></p><p><a href="https://www.cnblogs.com/shunyao8210/archive/2008/11/13/1332591.html" target="_blank" rel="noopener">https://www.cnblogs.com/shunyao8210/archive/2008/11/13/1332591.html</a></p><p><a href="https://book.douban.com/subject/2154713/" target="_blank" rel="noopener">《精通正则表达式》</a></p></blockquote><p>最近在准备面试，顺手比较系统的回顾并学习了“正则表达式”<br>这里是<a href="./正则表达式.pdf">笔记pdf</a></p><p>不过需要注意的几点是：</p><ol><li>JavaScript对于正则的支持是什么版本(或者流派？)</li><li>不同的写法有时候能达到同样的匹配范围，但是效率很可能有很大差别</li><li>永远是根据实际的使用场景来构造正则表达式，没有一劳永逸的写法</li><li>适合场景的才是最好的，换句话说，够用就好</li><li>在<a href="https://regex101.com" target="_blank" rel="noopener">regex101</a>上多尝试，一边学，一边练</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;正则表达式&quot;&gt;&lt;a href=&quot;#正则表达式&quot; class=&quot;headerlink&quot; title=&quot;正则表达式&quot;&gt;&lt;/a&gt;正则表达式&lt;/h1&gt;&lt;p&gt;参考&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://imweb.io/topic/56e
      
    
    </summary>
    
    
    
      <category term="Javascript" scheme="http://www.randomyang.top/tags/Javascript/"/>
    
      <category term="Regex" scheme="http://www.randomyang.top/tags/Regex/"/>
    
      <category term="正则表达式" scheme="http://www.randomyang.top/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="基础" scheme="http://www.randomyang.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>CSS中的几种“滤镜”</title>
    <link href="http://www.randomyang.top/2019/02/04/filter-mix-blend-mode-bachground-blend-mode/"/>
    <id>http://www.randomyang.top/2019/02/04/filter-mix-blend-mode-bachground-blend-mode/</id>
    <published>2019-02-04T06:51:35.000Z</published>
    <updated>2020-03-06T05:05:37.453Z</updated>
    
    <content type="html"><![CDATA[<h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>应用场景：filter CSS属性将模糊或颜色偏移等图形效果应用于元素。滤镜通常用于调整图像，背景和边框的渲染。<br>作用对象：作用于使用该属性的<strong>元素本身</strong><br>具体应用实例：<a href="https://codepen.io/randomyang/pen/ajvdvG" target="_blank" rel="noopener">DEMO</a></p><h4 id="mix-blend-mode"><a href="#mix-blend-mode" class="headerlink" title="mix-blend-mode"></a>mix-blend-mode</h4><p>应用场景：mix-blend-mode CSS 属性描述了元素本身应该与元素的背景(元素后面的任何内容)如何混合。<br>作用对象：作用于使用该属性的<strong>元素本身</strong><br>具体应用实例：<a href="https://codepen.io/randomyang/pen/RJrwJo" target="_blank" rel="noopener">DEMO</a></p><h4 id="background-blend-mode"><a href="#background-blend-mode" class="headerlink" title="background-blend-mode"></a>background-blend-mode</h4><p>应用场景：background-blend-mode CSS属性定义该元素的背景(背景图片、背景色等等)之间如何混合。通常结合<code>background-image</code>属性使用。<br>作用对象：作用于使用该属性的元素的<strong>背景</strong><br>具体应用实例：<a href="https://codepen.io/randomyang/pen/pLmZjM" target="_blank" rel="noopener">DEMO</a></p><h4 id="三者的相同点"><a href="#三者的相同点" class="headerlink" title="三者的相同点"></a>三者的相同点</h4><ul><li>都属于Blend混合效果的“滤镜”(这里所讲的滤镜不仅仅指<code>filter</code>属性)</li><li>都用通过某种形式，改变元素的显示效果</li><li>都可以混合使用，多个属性同时叠加作用于同一个元素</li><li>其中<code>mix-blend-mode</code>和<code>background-blend-mode</code>更是非常的相似，就连<code>系统可见值</code>几乎都是一样的。</li></ul><h4 id="三者的不同点"><a href="#三者的不同点" class="headerlink" title="三者的不同点"></a>三者的不同点</h4><ul><li>作用的对象不同（参见上文）</li><li><code>filter</code>和<code>mix-blend-mode | background-blend-mode</code>的<code>系统可见值</code>不同<br><code>filter</code>有：blur | brightness | contrast | drop-shadow | grayscale | hue-rotate | invert | opacity | saturate | sepia<br><code>mix-blend-mode | background-blend-mode</code>有：normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity;</li></ul><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p><strong><code>filter</code></strong>：<br>可以类比为你带着各种各样“有色眼镜”，在这种情况下再去观看被添加<code>filter</code>属性的元素。<br><strong><code>mix-blend-mode</code></strong>：<br>可以理解为，在一个像素上同时显示来自两个元素的像素，那么该怎么显示呢？显示什么颜色呢？这就要取决于你的<strong>混合模式</strong>了。<br>而这两个元素则分别是被设置了<code>mix-blend-mode</code>属性的元素及位于其之后的元素。<br><strong><code>background-blend-mode</code></strong>：可以理解为，其他地方和<code>mix-blend-mode</code>类似，但是混合的对象不是来自不同的元素，而是来自同一个元素的不同背景层。设置该属性，<strong>不会</strong>影响元素背景之上的元素。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/blend-mode" target="_blank" rel="noopener">混合模式 <blend-mode></blend-mode></a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/filter" target="_blank" rel="noopener">MDN filter</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/mix-blend-mode" target="_blank" rel="noopener">MDN mix-blend-mode</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-blend-mode" target="_blank" rel="noopener">background-blend-mode</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;filter&quot;&gt;&lt;a href=&quot;#filter&quot; class=&quot;headerlink&quot; title=&quot;filter&quot;&gt;&lt;/a&gt;filter&lt;/h4&gt;&lt;p&gt;应用场景：filter CSS属性将模糊或颜色偏移等图形效果应用于元素。滤镜通常用于调整图像，背景和边框的渲
      
    
    </summary>
    
    
    
      <category term="css" scheme="http://www.randomyang.top/tags/css/"/>
    
      <category term="filter" scheme="http://www.randomyang.top/tags/filter/"/>
    
      <category term="blend-mode" scheme="http://www.randomyang.top/tags/blend-mode/"/>
    
      <category term="总结" scheme="http://www.randomyang.top/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="易混" scheme="http://www.randomyang.top/tags/%E6%98%93%E6%B7%B7/"/>
    
  </entry>
  
  <entry>
    <title>前端开发者应该知道的浏览器渲染优化</title>
    <link href="http://www.randomyang.top/2019/01/28/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%80%85%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96/"/>
    <id>http://www.randomyang.top/2019/01/28/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%80%85%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96/</id>
    <published>2019-01-28T11:44:45.000Z</published>
    <updated>2020-03-08T05:19:55.970Z</updated>
    
    <content type="html"><![CDATA[<p>有过计算机图形基础知识的人都知道，渲染流程其实很复杂，在计算机底层 <code>CPU</code>,<code>GPU</code> 在不同的时刻需要各自进行不同的计算。</p><p>对于前端开发者来说，虽不用像专业计算机图形学领域的人一样对其中的每一个步骤都理解掌握，但若能做到对于浏览器的渲染有一个清晰的认识，必然会对理解web性能优化有很大的帮助。</p><h4 id="对于前端开发者来说，从以下5个方面进行浏览器的渲染优化："><a href="#对于前端开发者来说，从以下5个方面进行浏览器的渲染优化：" class="headerlink" title="对于前端开发者来说，从以下5个方面进行浏览器的渲染优化："></a>对于前端开发者来说，从以下5个方面进行浏览器的渲染优化：</h4><h4 id="1-Javascript"><a href="#1-Javascript" class="headerlink" title="1. Javascript"></a>1. Javascript</h4><ul><li><code>requestAnimationFrame</code>:<br>告诉浏览器您希望执行动画并请求浏览器调用指定的函数以在下次重绘之前更新动画</li><li>Web Workers:<br>为资源密集型JavaScript代码创建新的线程</li></ul><h4 id="2-样式计算-Style-Calculation"><a href="#2-样式计算-Style-Calculation" class="headerlink" title="2. 样式计算(Style Calculation)"></a>2. 样式计算(Style Calculation)</h4><ul><li>css property styles:<br>通过查询<a href="https://csstriggers.com" target="_blank" rel="noopener">https://csstriggers.com</a>了解各个css属性都会渲染的流程产生什么样的影响</li><li>selector matching:<br>选择器的解析也会对渲染性能产生较大的影响。选择器的选择越“精确”，则解析所耗费的性能越大。所以尽量使用<strong>类选择器(class selector)</strong>也是提升性能的一种方法。</li></ul><h4 id="3-布局的创建-Layout-Creation"><a href="#3-布局的创建-Layout-Creation" class="headerlink" title="3. 布局的创建(Layout Creation)"></a>3. 布局的创建(Layout Creation)</h4><ul><li>layout thrashing:<br>一个主要的性能瓶颈是布局颠簸。当在JavaScript中进行与样式更改交错的几何值请求并导致浏览器重排布局时，会发生这种情况。<br>这样，当快速连续几次完成时，会导致强制同步布局(forced synchronous layout)。</li><li>forced synchronous layouts:<br><a href="https://developers.google.com/web/tools/chrome-devtools/rendering-tools/forced-synchronous-layouts?hl=zh-cn" target="_blank" rel="noopener">强制同步布局</a></li></ul><h4 id="4-屏幕像素的绘制-Painting-of-Screen-Pixel"><a href="#4-屏幕像素的绘制-Painting-of-Screen-Pixel" class="headerlink" title="4. 屏幕像素的绘制(Painting of Screen Pixel)"></a>4. 屏幕像素的绘制(Painting of Screen Pixel)</h4><ul><li>multiple surface(layers):<br>当浏览器开始填充屏幕像素时发生绘画。这涉及在屏幕上绘制所有视觉元素。这是在多个表面上完成的，称为图层。<br>大量的绘制会导致严重的性能问题，尤其是在页面滚动的时候。</li><li>chrome dev tools:<br>chrome开发者工具中的<code>Rendering</code>可以清楚的查看当前页面哪些部分正在被绘制(painting)</li></ul><h4 id="5-渲染图层的合并-Layer-Composition"><a href="#5-渲染图层的合并-Layer-Composition" class="headerlink" title="5. 渲染图层的合并(Layer Composition)"></a>5. 渲染图层的合并(Layer Composition)</h4><ul><li><p><code>will-change: transform</code>:<br>当浏览器必须绘制<strong>彼此重叠</strong>的页面元素并且彼此存在于<strong>同一层中</strong>时，会出现由于绘制而导致的性能瓶颈。要解决此问题，所涉及的元素必须存在于<strong>单独的层</strong>中。<br>下面的css代码可以开启浏览器的此功能：</p><pre><code class="hljs undefined">&lt;element_to_promote&gt; &#123;    will-<span class="hljs-string">change:</span> transform <span class="hljs-regexp">/ opacity /</span> ...; <span class="hljs-comment">// 将要发生的动画变化类型</span>&#125;</code></pre></li><li><p>chrome dev tools:<br>chrome开发者工具中的<code>Layers</code>可以清楚的查看当前页面的图层(layer)层叠关系</p></li></ul><blockquote><p>本文参考 <a href="https://scotch.io/tutorials/browser-rendering-optimizations-for-frontend-development#toc-the-browser-s-rendering-path-and-various-optimizations" target="_blank" rel="noopener">Browser Rendering Optimizations for Frontend Development</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有过计算机图形基础知识的人都知道，渲染流程其实很复杂，在计算机底层 &lt;code&gt;CPU&lt;/code&gt;,&lt;code&gt;GPU&lt;/code&gt; 在不同的时刻需要各自进行不同的计算。&lt;/p&gt;
&lt;p&gt;对于前端开发者来说，虽不用像专业计算机图形学领域的人一样对其中的每一个步骤都理解掌握，
      
    
    </summary>
    
    
    
      <category term="Graphic" scheme="http://www.randomyang.top/tags/Graphic/"/>
    
      <category term="front-end" scheme="http://www.randomyang.top/tags/front-end/"/>
    
      <category term="浏览器" scheme="http://www.randomyang.top/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="性能优化" scheme="http://www.randomyang.top/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Pixels并不简单</title>
    <link href="http://www.randomyang.top/2019/01/27/Pixels%E5%B9%B6%E4%B8%8D%E7%AE%80%E5%8D%95/"/>
    <id>http://www.randomyang.top/2019/01/27/Pixels%E5%B9%B6%E4%B8%8D%E7%AE%80%E5%8D%95/</id>
    <published>2019-01-27T08:03:42.000Z</published>
    <updated>2020-03-06T05:05:32.243Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="PX-css-pixels"><a href="#PX-css-pixels" class="headerlink" title="PX(css pixels)"></a>PX(css pixels)</h4><blockquote><p><strong>虚拟像素</strong>，可以理解为“直觉”像素，<code>CSS</code>和<code>JS</code>使用的抽象单位，浏览器内的一切长度都是以<code>CSS</code>像素为单位的，<code>CSS</code>像素的单位是<strong>px</strong>.</p></blockquote><h4 id="DP-device-pixels"><a href="#DP-device-pixels" class="headerlink" title="DP(device pixels)"></a>DP(device pixels)</h4><blockquote><p><strong>设备像素（物理像素）</strong>顾名思义，显示屏是由一个个<strong>物理像素</strong>点组成的，通过控制每个像素点的颜色，使屏幕显示出不同的图像，屏幕从工厂出来那天起，它上面的<strong>物理像素点</strong>就固定不变了，单位<strong>pt</strong>.</p></blockquote><h4 id="DIP-Device-independent-Pixel"><a href="#DIP-Device-independent-Pixel" class="headerlink" title="DIP(Device independent Pixel)"></a>DIP(Device independent Pixel)</h4><blockquote><p>设备独立像素，也称为逻辑像素，简称<code>dip</code></p><p><strong>CSS像素 = 设备独立像素 = 逻辑像素</strong></p></blockquote><h4 id="DPR-device-pixels-ratio"><a href="#DPR-device-pixels-ratio" class="headerlink" title="DPR(device pixels ratio)"></a>DPR(device pixels ratio)</h4><blockquote><p><strong>设备像素比dpr</strong> 描述的是未缩放状态下，<code>物理像素</code>和<code>CSS像素</code>的初始比例关系</p><p>dpr = 设备像素 / css像素</p><p>dpr = 屏幕横向设备像素 / 理想视口的宽</p></blockquote><p><img src="/2019/01/27/Pixels并不简单/1.png" alt="1.0"></p><h4 id="参考像素"><a href="#参考像素" class="headerlink" title="参考像素"></a>参考像素</h4><blockquote><p><strong>参考像素</strong>即为从一臂之遥看解析度为<code>96DPI</code>的设备输出（即1英寸96点）时，1点（即1/96英寸）的视角。它并不是1/96英寸长度，而是从一臂之遥的距离处看解析度为<code>96DPI</code>的设备输出一单位（即1/96英寸）时视线与水平线的夹角.</p></blockquote><p>通常认为常人臂长为28英寸，所以它的视角是:</p><p>(1/96)in / (28in * 2 * PI / 360deg) = 0.0213度</p><p><img src="/2019/01/27/Pixels并不简单/2.png" alt="2.0"><br><small>图片来源：<a href="https://github.com/jawil/blog/issues/21" target="_blank" rel="noopener">https://github.com/jawil/blog/issues/21</a></small></p><h4 id="PPI-pixels-per-inch"><a href="#PPI-pixels-per-inch" class="headerlink" title="PPI(pixels per inch)"></a>PPI(pixels per inch)</h4><blockquote><p><strong>每英寸像素取值</strong>，更确切的说法应该是像素密度，也就是衡量单位物理面积内拥有像素值的情况.</p></blockquote><h4 id="DPI-dot-per-inch"><a href="#DPI-dot-per-inch" class="headerlink" title="DPI(dot per inch)"></a>DPI(dot per inch)</h4><blockquote><p><strong>dpi</strong>：每英寸多少点</p></blockquote><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://github.com/jawil/blog/issues/21" target="_blank" rel="noopener">CSS像素、物理像素、逻辑像素、设备像素比、PPI、Viewport</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio" target="_blank" rel="noopener">MDN/window.devicePixelRatio</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h3&gt;&lt;h4 id=&quot;PX-css-pixels&quot;&gt;&lt;a href=&quot;#PX-css-pixels&quot; class=&quot;headerlink
      
    
    </summary>
    
    
    
      <category term="front-end" scheme="http://www.randomyang.top/tags/front-end/"/>
    
      <category term="开发" scheme="http://www.randomyang.top/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="单位" scheme="http://www.randomyang.top/tags/%E5%8D%95%E4%BD%8D/"/>
    
      <category term="像素" scheme="http://www.randomyang.top/tags/%E5%83%8F%E7%B4%A0/"/>
    
      <category term="pixel" scheme="http://www.randomyang.top/tags/pixel/"/>
    
  </entry>
  
  <entry>
    <title>「深度学习」入门笔记</title>
    <link href="http://www.randomyang.top/2019/01/25/%E3%80%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8D%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.randomyang.top/2019/01/25/%E3%80%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8D%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</id>
    <published>2019-01-25T05:02:17.000Z</published>
    <updated>2020-03-06T05:05:55.294Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h4><p>(ps：根据视频本身的字幕总结的，可能不会很精确)</p><ul><li>activation 激活值</li><li>weight 权值</li><li>bias 偏置值</li><li>sigmod 压缩/映射函数</li><li>loss function 损失函数：和 cost function 常常混用</li><li>cost function 代价函数：差的平方和，来衡量不精确性</li><li>average cost 代价平均值（经验风险）：用几万个样本输出结果，衡量训练后的神经网络的好坏</li><li>back propagation 反向传播算法</li><li>gradient descent 梯度下降</li></ul><h4 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h4><p>视频资源来自大名鼎鼎的<strong>3Blue1Brown</strong>，该系列分三集，循序渐进的带你入门“深度学习”。用<strong>生动形象、精确而美</strong>的动画作为展示，用<strong>简单的易懂</strong>的例子举例。<br><a href="https://space.bilibili.com/88461692/channel/detail?cid=26587" target="_blank" rel="noopener">bilibili视频源</a></p><h4 id="以我自己理解的角度为路线的笔记："><a href="#以我自己理解的角度为路线的笔记：" class="headerlink" title="以我自己理解的角度为路线的笔记："></a>以我自己理解的角度为路线的笔记：</h4><p><a href="./深度学习入门笔记-神经网络的结构、梯度下降法.pdf">深度学习入门笔记-神经网络的结构、梯度下降法.pdf</a><br><a href="./深度学习入门笔记-反向传播算法.pdf">深度学习入门笔记-反向传播算法.pdf</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;基本术语&quot;&gt;&lt;a href=&quot;#基本术语&quot; class=&quot;headerlink&quot; title=&quot;基本术语&quot;&gt;&lt;/a&gt;基本术语&lt;/h4&gt;&lt;p&gt;(ps：根据视频本身的字幕总结的，可能不会很精确)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;activation 激活值&lt;/li&gt;
&lt;li
      
    
    </summary>
    
    
    
      <category term="笔记" scheme="http://www.randomyang.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="摘记" scheme="http://www.randomyang.top/tags/%E6%91%98%E8%AE%B0/"/>
    
      <category term="机器学习" scheme="http://www.randomyang.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="深度学习" scheme="http://www.randomyang.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="ML" scheme="http://www.randomyang.top/tags/ML/"/>
    
  </entry>
  
</feed>
